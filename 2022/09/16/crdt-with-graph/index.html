<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.feakin.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="与常规的在线可视化协作相比较，对于 Feakin 这一类的图即代码的绘图工具来说，其在线协作可以直接简化为三个元素：  在线：通讯协议与数据格式 协作：中心化还是去中心化？ 编辑：多端 CRDT与编辑器集成  从技术的层面来说，这些问题并不复杂，只是熟悉概念需要一个过程。但是呢，「中心化还是去中心化」这个问题非常有意思，毕竟从 Web 3.0 的韭菜热度来看，未来人们更想到去中心化的世界。 PS：">
<meta property="og:type" content="article">
<meta property="og:title" content="CRDT 在 Feakin 中的应用">
<meta property="og:url" content="https://blog.feakin.com/2022/09/16/crdt-with-graph/index.html">
<meta property="og:site_name" content="Feakin - Blog">
<meta property="og:description" content="与常规的在线可视化协作相比较，对于 Feakin 这一类的图即代码的绘图工具来说，其在线协作可以直接简化为三个元素：  在线：通讯协议与数据格式 协作：中心化还是去中心化？ 编辑：多端 CRDT与编辑器集成  从技术的层面来说，这些问题并不复杂，只是熟悉概念需要一个过程。但是呢，「中心化还是去中心化」这个问题非常有意思，毕竟从 Web 3.0 的韭菜热度来看，未来人们更想到去中心化的世界。 PS：">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-09-16T22:50:20.000Z">
<meta property="article:modified_time" content="2022-09-16T14:51:11.561Z">
<meta property="article:author" content="Feakin Org.">
<meta property="article:tag" content="Feakin,Graph,Ops">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.feakin.com/2022/09/16/crdt-with-graph/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>CRDT 在 Feakin 中的应用 | Feakin - Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Feakin - Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">GraphOps</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://blog.feakin.com/2022/09/16/crdt-with-graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Feakin Org.">
      <meta itemprop="description" content="Modernize graph assets management, based on Diagram-as-code, so you can create, share and edit diagram. Support for import Mermaid, PlantUML, Excalidraw, Dot and more.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Feakin - Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CRDT 在 Feakin 中的应用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-09-16 22:50:20 / Modified: 14:51:11" itemprop="dateCreated datePublished" datetime="2022-09-16T22:50:20+00:00">2022-09-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>与常规的在线可视化协作相比较，对于 Feakin 这一类的图即代码的绘图工具来说，其在线协作可以直接简化为三个元素：</p>
<ul>
<li>在线：通讯协议与数据格式</li>
<li>协作：中心化还是去中心化？</li>
<li>编辑：多端 CRDT与编辑器集成</li>
</ul>
<p>从技术的层面来说，这些问题并不复杂，只是熟悉概念需要一个过程。但是呢，「中心化还是去中心化」这个问题非常有意思，毕竟从 Web 3.0 的韭菜热度来看，未来人们更想到<strong>去中心化</strong>的世界。</p>
<p>PS：在线绘图 Demo：<a target="_blank" rel="noopener" href="https://online.feakin.com/">https://online.feakin.com/</a> ，可以通过复制 Room ID 给其他人来实现协作。服务器部署在 Heroku 上，代码见：<a target="_blank" rel="noopener" href="https://github.com/feakin/feakin/">https://github.com/feakin/feakin/</a> 。</p>
<h2 id="在线：通讯协议"><a href="#在线：通讯协议" class="headerlink" title="在线：通讯协议"></a>在线：通讯协议</h2><p>在线协作，意味着实时性，依赖于构建持续的长连接。关于如何构建这种连接的过程与方式，在不同的场景下，它被总结为不同的通讯协议，诸如于在 IoT 领域流行的 MQTT、CoAP、LWM2M 等。</p>
<h3 id="通讯协议：WebSocket-vs-HTTP"><a href="#通讯协议：WebSocket-vs-HTTP" class="headerlink" title="通讯协议：WebSocket vs HTTP"></a>通讯协议：WebSocket vs HTTP</h3><p>回到，如何保持在线协议这个问题，在浏览器端，基本上不就是无脑 WebSocket 嘛，学习门槛最低。</p>
<p>不过呢，在探索的过程中，有一个社区发起的同步 HTTP 协议 <a target="_blank" rel="noopener" href="https://braid.org/">Braid Protocol</a>，引用了我的兴趣。它自定义了一个 209  <a target="_blank" rel="noopener" href="https://github.com/braid-org/braid-spec/issues/106">Subscriptions</a> 状态码，使用 HTTP 长连接来接受更新，使用 HTTP Patch 来更新 patch。从语义上来说，Patch 操作确实很适合于这个场景。在有了这一类的状态同步协议，那么使用 HTTP 也可以实现 P2P 网络。不过，其主要用途还是用于使 Web 资源能够在多个客户端、服务器和代理之间<strong>自动同步</strong>，并支持多个编写者在任意网络延迟和分区下进行任意同时编辑，同时使用 OT、CRDT 或其他算法保证一致性。</p>
<p>简单来说，协议的初衷就是<strong>为协作而设计的</strong>。作为一个早期阶段的协议，自然是没有多大胆量采用。不过，试了试官方的 Demo，在 Firefox 和 Chrome 浏览器上都可以工作，Chrome 浏览器还显示了自定义的 Header。</p>
<h3 id="数据格式：JSON-vs-Binary"><a href="#数据格式：JSON-vs-Binary" class="headerlink" title="数据格式：JSON vs Binary"></a>数据格式：JSON vs Binary</h3><p>随后，在协作的过程中，会产生大量的数据，我们也需要定义好数据。从当前的研究来看，主流采用的都是二进制的形式，从性能上来更优。</p>
<p>不过，在当前的 Feakin 版本里，为了调试方便（主要是没有 E2E 测试），采用的就是 JSON 形式的数据格式，未来已经切到二进制文档。最后在 Feakin 里，我们使用了 Actix + WebSocket 来实现这个功能。从实现上还是有点 trick，官方的 demo 实现的时候有点奇怪。基本的数据结构如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]</span></span><br><span class="line"><span class="meta">#[serde(tag = <span class="string">&quot;type&quot;</span>, content = <span class="string">&quot;value&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">ActionType</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">CreateRoom</span>(CreateRoom),</span><br><span class="line">  <span class="title function_ invoke__">JoinRoom</span>(JoinRoom),</span><br><span class="line">  <span class="title function_ invoke__">LeaveRoom</span>(LeaveRoom),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// patches</span></span><br><span class="line">  <span class="title function_ invoke__">UpdateByVersion</span>(UpdateByVersion),</span><br><span class="line">  <span class="title function_ invoke__">OpsByPatches</span>(OpsByPatches),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感谢 Rust 神奇的 Enum 类型，简化了我的复制和粘贴。不过，从命名的角度来说，依旧有很大的改善空间。</p>
<h2 id="协作算法：中心化还是去中心化？"><a href="#协作算法：中心化还是去中心化？" class="headerlink" title="协作算法：中心化还是去中心化？"></a>协作算法：中心化还是去中心化？</h2><p>接着，让我们再回到核心问题上。</p>
<p>多人协作本质就是一个分布式系统中的一致性问题。在我们协作的过程中，自然会出现各种的冲突：当 A 修改了文档，这个变更会在本地保存，并异步复制给其他正在编辑此文档的用户。而当 A 在修改标题时，B 也在修改时，此时就会造成冲突。应对于冲突的产生，有不同的方案，诸如于一种简单的方案是在此时将 title 锁定住，不让其他人修改；还可以是 Last-write-wins 策略，即谁最后写入就用谁的。</p>
<p>大量的分布式系统相关的问题，都可以在数据库相关领域的书籍中看到，诸如于《数据密集型应用系统设计》、《数据库系统内幕》。对于我来说，有一些概念，我也是从中现学现用的。不过，如果你要是有兴趣，也可以从开发 Feakin 的过程中学到更多。</p>
<h3 id="OT-算法-vs-CRDT"><a href="#OT-算法-vs-CRDT" class="headerlink" title="OT 算法 vs CRDT"></a>OT 算法 vs CRDT</h3><p>在协作上，当前基本上主流的就是两个流派：</p>
<ul>
<li>中心化。客户端需要一直保持与服务器的连接，一旦离线了，那么就无法协作。代表是 OT ，核心部分是：管理转换过程的通用控制算法、 执行操作的转换函数，为此这里的操作需要细化到<strong>原子操作</strong>。</li>
<li>去中心化。客户端允许短暂的离线，并在恢复后同步，还允许没有服务端的存在。代表是 CRDT ，一种简化分布式数据存储系统和多用户应用程序的数据结构。主要可用于跨设备同步（如 Apple Notes）、分布式数据库、协作软件、大规模数据存储和处理系统等。</li>
</ul>
<p>这也是从顶层设计上， OT 与 CRDT 的巨大差异之处。另外一些差异在于 OT 更多的是针对于文本数据，而 CRDT 则可以针对于文本、任意 JSON 数据。这也就是为什么大量的分布式数据库，诸如于 Redis、Riak 会使用它的原因。</p>
<p><strong>OT</strong></p>
<p>从名称上来说，OT（Operational Transform，操作转换） 主要基于操作的，客户端生成操作，再将由服务端处理，服务端处理完，推给其他客户端。根据不同的场景，可以支持不同的操作，如 CKEditor 中的：Insert、Delete、Split、Merge 等。</p>
<p>服务端是整个 OT 的核心所在，而客户端在接收到更新的请求后，也需要具备和服务端相同的合并代码。既然如此，那么我们为什么不做成去中心化的呢？</p>
<p><strong>CRDT</strong></p>
<p>从名称上来说，(Conflict-Free Replicated data types<strong>，</strong>无冲突复制数据类型) 主要是基于状态的，CRDT 的思路是尽可能避免冲突，如此一来，我们就不需要解决冲突。在发生变更时，就生成 patch，发送到其他端，如服务器、客户端等。当我们使用 CRDT 进行文本协作时，每一个字符视为一个实体。</p>
<p>当我们在客户端编辑的时候，可以生成一个 patch，这个 patch 可以由其他端进行 merge，诸如于客户端：<code>self.inner.decode_and_add(&amp;patches)</code>，又或者是客户端的：<code>doc.mergeBytes(bytes)</code>。</p>
<hr>
<p>从结论说起， OT 设计起来很简单，实现想来复杂，但是在极端场景下很复杂。而 CRDT 则是在设计阶段很复杂，除非能设计一个理想的<strong>数据模型</strong>，否则在需求不断变化的情况下，模型就成了一个问题。诸如于，针对富文本的属性（attribute）这一点上，与纯文本存在巨大的差异。这也就是富文本与纯代码实现的差异，诸如于如 CKEditor 的作者在「<a target="_blank" rel="noopener" href="https://ckeditor.com/blog/Lessons-learned-from-creating-a-rich-text-editor-with-real-time-collaboration/">Lessons learned from creating a rich-text editor with real-time collaboration</a>)」一文中所说，OT 具有更好的可扩展性 —— 因为不需要更多的预先设计，可以很方便地添加一些操作，诸如于重命名、插件等。</p>
<p>在此这里，我还没有仔细研究各类 CRDT 实现的差异，这些差异点的分析，留给未来写数据库的时候来实现。如果你对 CRDT 有兴趣，可以看这个视频：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=x7drE24geUw">CRDTs: The Hard Parts</a>。</p>
<h3 id="歪个楼：回顾一下-Git-的基本概念"><a href="#歪个楼：回顾一下-Git-的基本概念" class="headerlink" title="歪个楼：回顾一下 Git 的基本概念"></a>歪个楼：回顾一下 Git 的基本概念</h3><p>从设计理念上来说，Git  也是一款针对于分布式设计的 “数据库管理” 工具：结合 SHA-1 哈希值来进行对象库（object database）的管理，并通过 <code>refs</code>、<code>HEAD</code>、<code>index</code> 等几个要素来构建其底层世界。</p>
<p>OT&#x2F;CRDT  等在实现上与 Git 极为相似，只是 OT&#x2F;CRDT 更像是一种实时的 Git-Rebase，获得 patch，自动就 rebase。除此在使用上，我们也并不会像 CRDT 一样使用 Git —— 为了保存这种最终强一致性：变更一个字符，便同步一次；删除一个字符，又同步一次。如果我们在真实的项目中，写入一个字符更 commit 一次，push 一次，虽然基本上不会产生冲突，但是我们的流水线大概率  99% 的时间都是挂的。</p>
<p>而我们的 ”编辑器&#x2F;IDE” 则会实现写入一个字符更 “提交&#x2F;触发” 变更，以便提供更智能的编辑服务。</p>
<h3 id="协作技术选型：Rust-与-Diamond-type"><a href="#协作技术选型：Rust-与-Diamond-type" class="headerlink" title="协作技术选型：Rust 与 Diamond-type"></a>协作技术选型：Rust 与 Diamond-type</h3><p>从成熟度来看，OT 显然是一种更成熟的方案，但是 CRDT 是一种更有前景的方案 —— 又学到了一种没有用的屠龙术。</p>
<p><strong>Rust</strong></p>
<p>为什么都是 Rust 语言呢？<del>因为我基本上只会在工作的时候使用 Java</del>，在去中心化的场景下，一种能跨端、系统、设备的语言必然是一种更好的选择。任何能够用 Rust 实现的应用系统，最终都必将用 Rust 实现。</p>
<p><strong>Rust CRDT</strong></p>
<p>在 CRDT 的技术选型上，有一系列的成熟选择：</p>
<ul>
<li>基于 Rust 语言的 <a target="_blank" rel="noopener" href="https://github.com/automerge/automerge-rs">Automerge RS</a> 提供了全方面的解决方案：服务器、浏览器端（WASM）、浏览器（JS） 等。</li>
<li>基于 Rust 语言与 Y.js 成熟经验的 <a target="_blank" rel="noopener" href="https://github.com/y-crdt/y-crdt">Y CRDT</a> 是一个更靠谱的方案。</li>
<li>基于 Rust 语言但是性能更好的 <strong><a target="_blank" rel="noopener" href="https://github.com/josephg/diamond-types">Diamond-type</a> ，</strong>其作者原来是 Google Wave 开发者，外加 ShareJS、ShareDB 的创始人。</li>
</ul>
<p>最后，我们选择的是 <a target="_blank" rel="noopener" href="https://github.com/josephg/diamond-types">Diamond-type</a>，虽然它 API 不完全，可能会带来更多的问题。但是，正经、成熟的方案谁在工作之后用啊。这种特别容易带来 error 的代码库，总会让你去想着，我要再造一个更好的轮子。</p>
<p>Tips：与采用代码相应的库相比，还有一种作法是通过数据库来解决，诸如于 <a target="_blank" rel="noopener" href="https://github.com/share/sharedb/">ShareDB</a>，不过它当前只支持 OT。在底层内建于对 CRDT 与协作的支持，会降低我们的开发成本。</p>
<h2 id="编辑：多端-CRDT-与编辑器集成"><a href="#编辑：多端-CRDT-与编辑器集成" class="headerlink" title="编辑：多端 CRDT 与编辑器集成"></a>编辑：多端 CRDT 与编辑器集成</h2><p>在选用了 Rust 作为 CRDT 的语言之后，我们就自然可以很好利用 Rust 语言的跨平台特性，将它编译为 WASM。如此一来，在浏览器端与服务端中，我们就可以使用同样的 CRDT API。</p>
<p>所以，剩下的工作就是日常的搬砖。</p>
<h3 id="服务端：Actix-Diamond-Types-CRDT"><a href="#服务端：Actix-Diamond-Types-CRDT" class="headerlink" title="服务端：Actix + Diamond Types + CRDT"></a>服务端：Actix + Diamond Types + CRDT</h3><p>对于服务端来说，它本身其实也是个客户端，只需要接受客户端生成的 patch 即可，在合并了 patch 之后，将它广播出去即可：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">before_version</span> = live.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">version</span>();</span><br><span class="line">after_version = <span class="keyword">self</span>.<span class="title function_ invoke__">ops_by_patches</span>(agent_name, patches).<span class="keyword">await</span>;</span><br><span class="line"><span class="comment">// or let after_version = self.insert(content, pos).await;</span></span><br><span class="line"><span class="comment">// or after_version = self.delete(range).await;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">patch</span> = coding.<span class="title function_ invoke__">patch_since</span>(&amp;before_version);</span><br></pre></td></tr></table></figure>

<p>Feakin，当前版本在这里，除了支持 patch，还可以同时支持 ins、del 这样的操。核心的代码就这么几行，剩下的代码都是 CRUD，没啥好玩的。</p>
<h3 id="客户端：编辑生成-patches"><a href="#客户端：编辑生成-patches" class="headerlink" title="客户端：编辑生成 patches"></a>客户端：编辑生成 patches</h3><p>从结果代码来说，这部分相当的简单：：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localVersion = doc.<span class="title function_">getLocalVersion</span>();</span><br><span class="line">event.<span class="property">changes</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">change1, change2</span>) =&gt;</span> change2.<span class="property">rangeOffset</span> - change1.<span class="property">rangeOffset</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">change</span> =&gt;</span> &#123;</span><br><span class="line">  doc.<span class="title function_">ins</span>(change.<span class="property">rangeOffset</span>, change.<span class="property">text</span>);</span><br><span class="line">  doc.<span class="title function_">del</span>(change.<span class="property">rangeOffset</span>, change.<span class="property">rangeLength</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> patch = doc.<span class="title function_">getPatchSince</span>(localVersion);</span><br></pre></td></tr></table></figure>

<p>由于在前端中 Feakin 采用的是 monaco 的实现，需要在发生变更时，执行 <code>ins</code> 和 <code>del</code> 等，以生成 patch。</p>
<h3 id="客户端：编辑器应用-patches"><a href="#客户端：编辑器应用-patches" class="headerlink" title="客户端：编辑器应用 patches"></a>客户端：编辑器应用 patches</h3><p>对于客户端来说，接受 patch 并应用也不复杂，然而我被坑了一晚上（被坑在了如何动态更新 Monaco 的模型上）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> merge_version = doc.<span class="title function_">mergeBytes</span>(bytes)</span><br><span class="line">doc.<span class="title function_">mergeVersions</span>(doc.<span class="title function_">getLocalVersion</span>(), merge_version);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">xfSinces</span>: <span class="title class_">DTOperation</span>[] = doc.<span class="title function_">xfSince</span>(patchInfo.<span class="property">before</span>);</span><br><span class="line">xfSinces.<span class="title function_">forEach</span>(<span class="function">(<span class="params">op</span>) =&gt;</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;);        </span><br></pre></td></tr></table></figure>

<p>唯一比较麻烦的点在于，当我们接受了 patch 之后，还需要把变更同步给编辑器。诸如于，我们接受了在 12 位置插入 a 字符，编辑器需要去插入这个 a。同时，在这个短暂的瞬间，我们还需要把编辑器锁住。</p>
<p>TIP：顺带一提，<a target="_blank" rel="noopener" href="https://github.com/yjs">yjs</a> 提供了不同编辑器的支持，可以在开发时，参考一下如何使用编辑器的 API —— 只要是 Monaco Editor 的 API 文档，一言难尽。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，我们再回顾一下我们所需要的三个元素：</p>
<ul>
<li>在线。如何选择合适的通讯协议和数据格式？</li>
<li>协作。如何基于 CRDT 构建去中心化的协作？</li>
<li>编辑。如何实现多端同步与编辑？</li>
</ul>
<p>在这里，虽然我们简单完成了 Feakin 的在线协作，但是我们依旧有一系列的东西可以玩：</p>
<ul>
<li>编码与解码优化。JSON 的序列化与反序列化会带来性能问题。</li>
<li>完善协作形态。诸如于 Cursor 的显示等。</li>
<li>异常场景处理。尚未处理各种异常状态</li>
</ul>
<p>除此呢，下一步，我们应该如何有结地结合在线协作与图即代码？诸如于：</p>
<ul>
<li>基于代码化的在线 DDD 协作设计</li>
<li>基于代码化的架构图绘制</li>
</ul>
<p>如果你对这些有兴趣，也欢迎来联系我们，加入 Feakin 的开发。</p>
<p>参考资源：</p>
<ul>
<li>《<a target="_blank" rel="noopener" href="https://josephg.com/blog/crdts-are-the-future/">I was wrong. CRDTs are the future</a>》</li>
<li>《<a target="_blank" rel="noopener" href="https://josephg.com/blog/crdts-go-brrr/">5000x faster CRDTs: An Adventure in Optimization</a>》</li>
<li><a target="_blank" rel="noopener" href="https://crdt.tech/">https://crdt.tech/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/yjs/y-monaco">https://github.com/yjs/y-monaco</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/feakin/awesome-frontend-graph-library">Awesome Opensource Graph Library</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/16/how-feakin-works/" rel="prev" title="Feakin 是如何设计与构建的？">
      <i class="fa fa-chevron-left"></i> Feakin 是如何设计与构建的？
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E7%BA%BF%EF%BC%9A%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.</span> <span class="nav-text">在线：通讯协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%EF%BC%9AWebSocket-vs-HTTP"><span class="nav-number">1.1.</span> <span class="nav-text">通讯协议：WebSocket vs HTTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%9AJSON-vs-Binary"><span class="nav-number">1.2.</span> <span class="nav-text">数据格式：JSON vs Binary</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E4%BD%9C%E7%AE%97%E6%B3%95%EF%BC%9A%E4%B8%AD%E5%BF%83%E5%8C%96%E8%BF%98%E6%98%AF%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">协作算法：中心化还是去中心化？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OT-%E7%AE%97%E6%B3%95-vs-CRDT"><span class="nav-number">2.1.</span> <span class="nav-text">OT 算法 vs CRDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%AA%E4%B8%AA%E6%A5%BC%EF%BC%9A%E5%9B%9E%E9%A1%BE%E4%B8%80%E4%B8%8B-Git-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.</span> <span class="nav-text">歪个楼：回顾一下 Git 的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E4%BD%9C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%EF%BC%9ARust-%E4%B8%8E-Diamond-type"><span class="nav-number">2.3.</span> <span class="nav-text">协作技术选型：Rust 与 Diamond-type</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%BE%91%EF%BC%9A%E5%A4%9A%E7%AB%AF-CRDT-%E4%B8%8E%E7%BC%96%E8%BE%91%E5%99%A8%E9%9B%86%E6%88%90"><span class="nav-number">3.</span> <span class="nav-text">编辑：多端 CRDT 与编辑器集成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%9AActix-Diamond-Types-CRDT"><span class="nav-number">3.1.</span> <span class="nav-text">服务端：Actix + Diamond Types + CRDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A%E7%BC%96%E8%BE%91%E7%94%9F%E6%88%90-patches"><span class="nav-number">3.2.</span> <span class="nav-text">客户端：编辑生成 patches</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A%E7%BC%96%E8%BE%91%E5%99%A8%E5%BA%94%E7%94%A8-patches"><span class="nav-number">3.3.</span> <span class="nav-text">客户端：编辑器应用 patches</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">小结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Feakin Org.</p>
  <div class="site-description" itemprop="description">Modernize graph assets management, based on Diagram-as-code, so you can create, share and edit diagram. Support for import Mermaid, PlantUML, Excalidraw, Dot and more.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Feakin Org.</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
